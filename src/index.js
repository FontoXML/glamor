/* stylesheet */
import { StyleSheet } from "./sheet.js";
import { createMarkupForStyles } from "./CSSPropertyOperations";
import clean from "./clean.js";

export const styleSheet = new StyleSheet();
// an isomorphic StyleSheet shim. hides all the nitty gritty.

// /**************** LIFTOFF IN 3... 2... 1... ****************/
styleSheet.inject(); //eslint-disable-line indent
// /****************      TO THE MOOOOOOON     ****************/

// plugins
import { PluginSet, fallbacks, contentWrap } from "./plugins"; // we include these by default
export const plugins = (styleSheet.plugins = new PluginSet([
  contentWrap,
  fallbacks,
]));
plugins.media = new PluginSet(); // neat! media, font-face, keyframes
plugins.fontFace = new PluginSet();
plugins.keyframes = new PluginSet([fallbacks]);

// define some constants

const isBrowser = typeof window !== "undefined";

// hashes a string to something 'unique'
// we use this to generate ids for styles
import hash from "./hash";

function hashify(obj) {
  let str = JSON.stringify(obj);
  let toRet = hash(str).toString(36);
  return toRet;
}

// of shape { 'data-css-<id>': '' }
function isLikeRule(rule) {
  let keys = Object.keys(rule).filter((x) => x !== "toString");
  if (keys.length !== 1) {
    return false;
  }
  return !!/data\-css\-([a-zA-Z0-9\-_]+)/.exec(keys[0]);
}

// extracts id from a { 'data-css-<id>': ''} like object
function idFor(rule) {
  let keys = Object.keys(rule).filter((x) => x !== "toString");
  if (keys.length !== 1) throw new Error("not a rule");
  let regex = /data\-css\-([a-zA-Z0-9\-_]+)/;
  let match = regex.exec(keys[0]);
  if (!match) throw new Error("not a rule");
  return match[1];
}

// from https://github.com/j2css/j2c/blob/5d381c2d721d04b54fabe6a165d587247c3087cb/src/helpers.js#L28-L61

// "Tokenizes" the selectors into parts relevant for the next function.
// Strings and comments are matched, but ignored afterwards.
// This is not a full tokenizers. It only recognizes comas, parentheses,
// strings and comments.
// regexp generated by scripts/regexps.js then trimmed by hand
var selectorTokenizer =
  /[(),]|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g;

/**
 * This will split a coma-separated selector list into individual selectors,
 * ignoring comas in strings, comments and in :pseudo-selectors(parameter, lists).
 *
 * @param {string} selector
 * @return {string[]}
 */

function splitSelector(selector) {
  if (selector.indexOf(",") === -1) {
    return [selector];
  }

  var indices = [],
    res = [],
    inParen = 0,
    o;
  /*eslint-disable no-cond-assign*/
  while ((o = selectorTokenizer.exec(selector))) {
    /*eslint-enable no-cond-assign*/
    switch (o[0]) {
      case "(":
        inParen++;
        break;
      case ")":
        inParen--;
        break;
      case ",":
        if (inParen) break;
        indices.push(o.index);
    }
  }
  for (o = indices.length; o--; ) {
    res.unshift(selector.slice(indices[o] + 1));
    selector = selector.slice(0, indices[o]);
  }
  res.unshift(selector);
  return res;
}

function selector(id, path) {
  if (!id) {
    return path.replace(/\&/g, "");
  }
  if (!path) return `.css-${id},[data-css-${id}]`;

  let x = splitSelector(path)
    .map((x) =>
      x.indexOf("&") >= 0
        ? [
            x.replace(/\&/gm, `.css-${id}`),
            x.replace(/\&/gm, `[data-css-${id}]`),
          ].join(",") // todo - make sure each sub selector has an &
        : `.css-${id}${x},[data-css-${id}]${x}`
    )
    .join(",");

  return x;
}

// end https://github.com/j2css/j2c/blob/5d381c2d721d04b54fabe6a165d587247c3087cb/src/helpers.js#L28-L61

function toCSS({ selector, style }) {
  let result = plugins.transform({ selector, style });
  return `${result.selector}{${createMarkupForStyles(result.style)}}`;
}

function deconstruct(style) {
  // we can be sure it's not infinitely nested here
  let plain, selects, medias, supports;
  Object.keys(style).forEach((key) => {
    if (key.indexOf("&") >= 0) {
      selects = selects || {};
      selects[key] = style[key];
    } else if (key.indexOf("@media") === 0) {
      medias = medias || {};
      medias[key] = deconstruct(style[key]);
    } else if (key.indexOf("@supports") === 0) {
      supports = supports || {};
      supports[key] = deconstruct(style[key]);
    } else if (key === "label") {
      if (style.label.length > 0) {
        plain = plain || {};
      }
    } else {
      plain = plain || {};
      plain[key] = style[key];
    }
  });
  return { plain, selects, medias, supports };
}

function deconstructedStyleToCSS(id, style) {
  let css = [];

  // plugins here
  let { plain, selects, medias, supports } = style;
  if (plain) {
    css.push(toCSS({ style: plain, selector: selector(id) }));
  }
  if (selects) {
    Object.keys(selects).forEach((key) =>
      css.push(toCSS({ style: selects[key], selector: selector(id, key) }))
    );
  }
  if (medias) {
    Object.keys(medias).forEach((key) =>
      css.push(`${key}{${deconstructedStyleToCSS(id, medias[key]).join("")}}`)
    );
  }
  if (supports) {
    Object.keys(supports).forEach((key) =>
      css.push(`${key}{${deconstructedStyleToCSS(id, supports[key]).join("")}}`)
    );
  }
  return css;
}

// this cache to track which rules have
// been inserted into the stylesheet
let inserted = (styleSheet.inserted = {});

// and helpers to insert rules into said styleSheet
function insert(spec) {
  if (!inserted[spec.id]) {
    inserted[spec.id] = true;
    let deconstructed = deconstruct(spec.style);
    let rules = deconstructedStyleToCSS(spec.id, deconstructed);
    inserted[spec.id] = isBrowser ? true : rules;
    rules.forEach((cssRule) => styleSheet.insert(cssRule));
  }
}

// a simple cache to store generated rules
let registered = (styleSheet.registered = {});
function register(spec) {
  if (!registered[spec.id]) {
    registered[spec.id] = spec;
  }
}

function _getRegistered(rule) {
  if (isLikeRule(rule)) {
    let ret = registered[idFor(rule)];
    if (ret == null) {
      throw new Error(
        "[glamor] an unexpected rule cache miss occurred. This is probably a sign of multiple glamor instances in your app. See https://github.com/threepointone/glamor/issues/79"
      );
    }
    return ret;
  }
  return rule;
}

// todo - perf
let ruleCache = {};
function toRule(spec) {
  register(spec);
  insert(spec);

  if (ruleCache[spec.id]) {
    return ruleCache[spec.id];
  }

  let ret = { [`data-css-${spec.id}`]: "" };
  Object.defineProperty(ret, "toString", {
    enumerable: false,
    value() {
      return "css-" + spec.id;
    },
  });
  ruleCache[spec.id] = ret;
  return ret;
}

function isSelector(key) {
  let possibles = [":", ".", "[", ">", " "],
    found = false,
    ch = key.charAt(0);
  for (let i = 0; i < possibles.length; i++) {
    if (ch === possibles[i]) {
      found = true;
      break;
    }
  }
  return found || key.indexOf("&") >= 0;
}

function joinSelectors(a, b) {
  let as = splitSelector(a).map((a) => (!(a.indexOf("&") >= 0) ? "&" + a : a));
  let bs = splitSelector(b).map((b) => (!(b.indexOf("&") >= 0) ? "&" + b : b));

  return bs
    .reduce((arr, b) => arr.concat(as.map((a) => b.replace(/\&/g, a))), [])
    .join(",");
}

function joinMediaQueries(a, b) {
  return a ? `@media ${a.substring(6)} and ${b.substring(6)}` : b;
}

function isMediaQuery(key) {
  return key.indexOf("@media") === 0;
}

function isSupports(key) {
  return key.indexOf("@supports") === 0;
}

function joinSupports(a, b) {
  return a ? `@supports ${a.substring(9)} and ${b.substring(9)}` : b;
}

// flatten a nested array
function flatten(inArr) {
  let arr = [];
  for (let i = 0; i < inArr.length; i++) {
    if (Array.isArray(inArr[i])) arr = arr.concat(flatten(inArr[i]));
    else arr = arr.concat(inArr[i]);
  }
  return arr;
}

const prefixedPseudoSelectors = {
  "::placeholder": [
    "::-webkit-input-placeholder",
    "::-moz-placeholder",
    "::-ms-input-placeholder",
  ],
  ":fullscreen": [
    ":-webkit-full-screen",
    ":-moz-full-screen",
    ":-ms-fullscreen",
  ],
};

// mutable! modifies dest.
function build(dest, { selector = "", mq = "", supp = "", src = {} }) {
  if (!Array.isArray(src)) {
    src = [src];
  }
  src = flatten(src);

  src.forEach((_src) => {
    if (isLikeRule(_src)) {
      let reg = _getRegistered(_src);
      if (reg.type !== "css") {
        throw new Error("cannot merge this rule");
      }
      _src = reg.style;
    }
    _src = clean(_src);
    if (_src && _src.composes) {
      build(dest, { selector, mq, supp, src: _src.composes });
    }
    Object.keys(_src || {}).forEach((key) => {
      if (isSelector(key)) {
        if (prefixedPseudoSelectors[key]) {
          prefixedPseudoSelectors[key].forEach((p) =>
            build(dest, {
              selector: joinSelectors(selector, p),
              mq,
              supp,
              src: _src[key],
            })
          );
        }

        build(dest, {
          selector: joinSelectors(selector, key),
          mq,
          supp,
          src: _src[key],
        });
      } else if (isMediaQuery(key)) {
        build(dest, {
          selector,
          mq: joinMediaQueries(mq, key),
          supp,
          src: _src[key],
        });
      } else if (isSupports(key)) {
        build(dest, {
          selector,
          mq,
          supp: joinSupports(supp, key),
          src: _src[key],
        });
      } else if (key === "composes") {
        // ignore, we already dealth with it
      } else {
        let _dest = dest;
        if (supp) {
          _dest[supp] = _dest[supp] || {};
          _dest = _dest[supp];
        }
        if (mq) {
          _dest[mq] = _dest[mq] || {};
          _dest = _dest[mq];
        }
        if (selector) {
          _dest[selector] = _dest[selector] || {};
          _dest = _dest[selector];
        }

        if (key === "label") {
        } else {
          _dest[key] = _src[key];
        }
      }
    });
  });
}

function _css(rules) {
  let style = { label: [] };
  build(style, { src: rules }); // mutative! but worth it.

  let spec = {
    id: hashify(style),
    style,
    label: "",
    type: "css",
  };
  return toRule(spec);
}

let nullrule = {
  // 'data-css-nil': ''
};
Object.defineProperty(nullrule, "toString", {
  enumerable: false,
  value() {
    return "css-nil";
  },
});

let inputCaches =
  typeof WeakMap !== "undefined"
    ? [nullrule, new WeakMap(), new WeakMap(), new WeakMap()]
    : [nullrule];

function multiIndexCache(fn) {
  return function (args) {
    if (inputCaches[args.length]) {
      let coi = inputCaches[args.length];
      let ctr = 0;
      while (ctr < args.length - 1) {
        if (!coi.has(args[ctr])) {
          coi.set(args[ctr], new WeakMap());
        }
        coi = coi.get(args[ctr]);
        ctr++;
      }
      if (coi.has(args[args.length - 1])) {
        let ret = coi.get(args[ctr]);

        if (registered[ret.toString().substring(4)]) {
          // make sure it hasn't been flushed
          return ret;
        }
      }
    }
    let value = fn(args);
    if (inputCaches[args.length]) {
      let ctr = 0,
        coi = inputCaches[args.length];
      while (ctr < args.length - 1) {
        coi = coi.get(args[ctr]);
        ctr++;
      }
      try {
        coi.set(args[ctr], value);
      } catch (err) {}
    }
    return value;
  };
}

let cachedCss = typeof WeakMap !== "undefined" ? multiIndexCache(_css) : _css;

export function css(...rules) {
  if (rules[0] && rules[0].length && rules[0].raw) {
    throw new Error(
      "you forgot to include glamor/babel in your babel plugins."
    );
  }

  rules = clean(rules);
  if (!rules) {
    return nullrule;
  }

  return cachedCss(rules);
}

function insertCss(css) {
  let spec = {
    id: hashify(css),
    css,
    type: "raw",
  };
  register(spec);
  if (!inserted[spec.id]) {
    styleSheet.insert(spec.css);
    inserted[spec.id] = isBrowser ? true : [spec.css];
  }
}

css.global = (selector, style) => {
  style = clean(style);
  if (style) {
    return insertCss(toCSS({ selector, style }));
  }
};

function insertKeyframe(spec) {
  if (!inserted[spec.id]) {
    let inner = Object.keys(spec.keyframes)
      .map((kf) => {
        let result = plugins.keyframes.transform({
          id: spec.id,
          name: kf,
          style: spec.keyframes[kf],
        });
        return `${result.name}{${createMarkupForStyles(result.style)}}`;
      })
      .join("");

    const rules = ["-webkit-", "-moz-", "-o-", ""].map(
      (prefix) => `@${prefix}keyframes ${spec.name + "_" + spec.id}{${inner}}`
    );
    rules.forEach((rule) => styleSheet.insert(rule));

    inserted[spec.id] = isBrowser ? true : rules;
  }
}
export const keyframes = (name, kfs) => {
  if (!kfs) {
    (kfs = name), (name = "animation");
  }

  // do not ignore empty keyframe definitions for now.
  kfs = clean(kfs) || {};
  let spec = {
    id: hashify({ name, kfs }),
    type: "keyframes",
    name,
    keyframes: kfs,
  };
  register(spec);
  insertKeyframe(spec);
  return name + "_" + spec.id;
};
